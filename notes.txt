

EPISODE - 1
*****************************************************

install express
create a server
create prot
listen to server
version controlling - ^4.16.3 ( if cap symbol is present then project version keeps auto updating minor and patch )
package.lock.json - will tell the exact version of the dependancies version ( because package.json version gets keep on updating . This file will lock the version)
~ - installs only patch updates not minor version
^ - installs minor version but not major version

SCENARIO -1 
-----------------
-> when the first route handler has route ('/') then since it matches all other routes this route handler will get returned. so the order is important
app.use("/", (req, res) => {
  res.send("hello just");
});

app.use("/test", (req, res) => {
  res.send("hello test");
});

app.use("/hello", (req, res) => {
  res.send("hello from route hello");
});

The first route handler is defined as app.use("/", ...).
This will match any route, including /test and /hello, because / is the root route, which matches everything.
Since it's at the top, it will always be hit first and send "hello just", even before the more specific /test and /hello routes.
The sequence of code is matters. Order of the code is important
play with route and route extensions 

SCENARIO- -2 
-------------
->DIFFERENCE BETWEEN app.use() and app.get(), post, delete, put, patch

Middleware and Route Handling in Action:
app.use() is typically used for middleware tasks like logging, authentication, or handling requests before they reach the route handler.

Route methods like app.get() are used for handling specific requests based on the HTTP method and route.

// This will run for all incoming requests to /test 
This middleware will only run for routes that start with /test, such as:
/test
/test/abc
/test/123/xyz

app.use("/test", (req, res, next) => {
  console.log("Middleware function for /test route");
  next();  // Pass to the next handler
});


EPISODE -  2
**********************************************

Connect with GIT - 
steps:- 

cd path/to/your/project
1.git init
2.git add .
3.git commit -m "Initial commit"
4.git remote add origin https://github.com/your-username/your-repo.git
5.git branch -M main  # Optional: rename to 'main' if needed
6.git push -u origin main
7.git config --global user.name "your-github-username"
8.git config --global user.email "your-email@example.com"
9.git push -u origin main

// request handler

// route matches -  regular expression
// -ab*cd -> "abjbdjdcbfiebcd" , "ab123cd" ( start with ab and ends with cd - in between it can have anything)
// -ab?c - > "ac","abc"
// -ab+c - > "abbbbbbbbbbc", "abbc" (starts with a and ends with c in between you can add as many b's as you want)
//  /a/ - > if in the path a is present then execute
//  /.*fly$/ - > starts with anything but should end with fly - "abdsdfly", "fly"

// request handler

// route matches -  regular expression
// -ab*cd -> "abjbdjdcbfiebcd" , "ab123cd" ( start with ab and ends with cd - in between it can have anything)
// -ab?c - > "ac","abc"
// -ab+c - > "abbbbbbbbbbc", "abbc" (starts with a and ends with c in between you can add as many b's as you want)
//  /a/ - > if in the path a is present then execute
//  /.*fly$/ - > starts with anything but should end with fly - "abdsdfly", "fly"

DIFFERENCE BETWEEN QUERY PARAMS AND DYNAMIC ROUTING
--------------------------------------------------------

app.get("/user", (req, res) => {
  // http://localhost:8000/user?userId=1&age=10
  console.log("query params", req.query);

  res.json({
    fname: "jyothi",
    lname: "kattamuri",
  });
});

// reading the dynamic routes

app.get("/user/:id/:name/:age", (req, res) => {
  // http://localhost:8000/user?userId=1&age=10
  console.log("by id's", req.params);

  res.json({
    fname: "jyothi",
    lname: "kattamuri",
  });
});

EPISODE - 3
***********************************















