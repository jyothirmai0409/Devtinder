

EPISODE - 1 ( create a server )
*****************************************************

install express
create a server
create prot
listen to server
version controlling - ^4.16.3 ( if cap symbol is present then project version keeps auto updating minor and patch )
package.lock.json - will tell the exact version of the dependancies version ( because package.json version gets keep on updating . This file will lock the version)
~ - installs only patch updates not minor version
^ - installs minor version but not major version

SCENARIO -1 
-----------------
-> when the first route handler has route ('/') then since it matches all other routes this route handler will get returned. so the order is important
app.use("/", (req, res) => {
  res.send("hello just");
});

app.use("/test", (req, res) => {
  res.send("hello test");
});

app.use("/hello", (req, res) => {
  res.send("hello from route hello");
});

The first route handler is defined as app.use("/", ...).
This will match any route, including /test and /hello, because / is the root route, which matches everything.
Since it's at the top, it will always be hit first and send "hello just", even before the more specific /test and /hello routes.
The sequence of code is matters. Order of the code is important
play with route and route extensions 

SCENARIO- -2 
-------------
->DIFFERENCE BETWEEN app.use() and app.get(), post, delete, put, patch

Middleware and Route Handling in Action:
app.use() is typically used for middleware tasks like logging, authentication, or handling requests before they reach the route handler.

Route methods like app.get() are used for handling specific requests based on the HTTP method and route.

// This will run for all incoming requests to /test 
This middleware will only run for routes that start with /test, such as:
/test
/test/abc
/test/123/xyz

app.use("/test", (req, res, next) => {
  console.log("Middleware function for /test route");
  next();  // Pass to the next handler
});


EPISODE -  2 ( Route handling )
**********************************************

Connect with GIT - 
steps:- 

cd path/to/your/project
1.git init
2.git add .
3.git commit -m "Initial commit"
4.git remote add origin https://github.com/your-username/your-repo.git
5.git branch -M main  # Optional: rename to 'main' if needed
6.git push -u origin main
7.git config --global user.name "your-github-username"
8.git config --global user.email "your-email@example.com"
9.git push -u origin main

// request handler

// route matches -  regular expression
// -ab*cd -> "abjbdjdcbfiebcd" , "ab123cd" ( start with ab and ends with cd - in between it can have anything)
// -ab?c - > "ac","abc"
// -ab+c - > "abbbbbbbbbbc", "abbc" (starts with a and ends with c in between you can add as many b's as you want)
//  /a/ - > if in the path a is present then execute
//  /.*fly$/ - > starts with anything but should end with fly - "abdsdfly", "fly"

// request handler

// route matches -  regular expression
// -ab*cd -> "abjbdjdcbfiebcd" , "ab123cd" ( start with ab and ends with cd - in between it can have anything)
// -ab?c - > "ac","abc"
// -ab+c - > "abbbbbbbbbbc", "abbc" (starts with a and ends with c in between you can add as many b's as you want)
//  /a/ - > if in the path a is present then execute
//  /.*fly$/ - > starts with anything but should end with fly - "abdsdfly", "fly"

DIFFERENCE BETWEEN QUERY PARAMS AND DYNAMIC ROUTING
--------------------------------------------------------

app.get("/user", (req, res) => {
  // http://localhost:8000/user?userId=1&age=10
  console.log("query params", req.query);

  res.json({
    fname: "jyothi",
    lname: "kattamuri",
  });
});

// reading the dynamic routes

app.get("/user/:id/:name/:age", (req, res) => {
  // http://localhost:8000/user?userId=1&age=10
  console.log("by id's", req.params);

  res.json({
    fname: "jyothi",
    lname: "kattamuri",
  });
});

EPISODE - 3 ( Middleware and error handling)
***********************************
SCENARIO - 1
app.use(
  "/",
  (req, res, next) => {
    console.log("test");
    res.send("first handler");
    next(); // This won't run after res.send(), but included for clarity
  },
  (req, res) => {
    console.log("2nd handler");
    res.send("2nd handler");
  }
);


- > In the above scenario we will get error because for same route we are trying to send multiple responses so we will get below error - Cannot set headers after they are sent to the client
-> javascript is executed line by line once next() is called then it goes to 2nd handler and prints console log but when it try to execute 2nd response it throws error
-> once it sends the response then it closes the coonection  ( tcp request and response concept)
-> even the below scenario also gives same error

SCENARIO -2 
-----------

app.use(
  "/",
  (req, res, next) => {
    console.log("test");
    next(); // This will run after res.send(), but included for clarity
    res.send("first handler");
  },
  (req, res) => {
    console.log("2nd handler");
    res.send("2nd handler");
  }
);

SCENARIO - 3
---------------
-> in the below scenario we will get "cannot get / " error because it is expecting route handler that sends response but there is not next route handler
app.use(
  "/",
  (req, res, next) => {
    console.log("test");
    next();
  },
  (req, res) => {
    console.log("2nd handler");
    next();
  },
  (req, res) => {
    console.log("3rd handler");
    next();
  }
);

SCENARIO - 4
---------------
-> since there is no next() , it keep on executing , will not give any error
app.use(
  "/",
  (req, res, next) => {
    console.log("test");
    next();
  },
  (req, res,next) => {
    console.log("2nd handler");
    next();
  },
  (req, res,next) => {
    console.log("3rd handler");
  }
);

SCENARIO - 5
---------------------
-> We can send array of route handlers 
-> app.use('/',[rh1,rh2,rh3],rh4,rh5)



SCENARIO - 6
---------------------
-> below case we will not get any error , since there is not next() , it will not go to 2nd toute handler
app.use("/", (req, res, next) => {
  console.log("test");
  res.send("hi there");
});

app.use("/", (req, res, next) => {
  console.log("test");
  next();
});

MIDDLEWARE USE CASE :- lets say when admin wants to get all users data or delete all usersdata, in both the cases we need to authenticate if the logged in user is admin or not , so in that scenario we can 
deal using middlewares because we can write middleware once and can be used at any route handler


// the below handler will handle anything that comes after /xyz, /test, /1 - so always place app.use carefully in the code either top or last
app.use("/admin", (req, res, next) => {
  const token = "xyz";
  const isAuth = token === "xyz";
  if (!isAuth) {
    res.status(401).send("Unauthorised");
  } else {
    next();
  }
});

app.get("/admin", (req, res) => {
  res.send("fetched users successfully");
});

app.delete("/", (req, res) => {
  res.send("deleted users successfully");
});

ERROR Handling
---------------------
app.get("/errorhandling", (req, res, next) => {
  try {
    throw new Error("something went wrong");
  } catch (err) {
    next(err); // pass the error to the error-handling middleware
  }
});


EPISODE - 4
---------------------

MONGODB - 
sign up in modngodb.com
create and deplot cluster - get the connection string 
download mongodb compass - mongodb.com/products/tools/compass 
add a connection string and create databases
database - collections - documents ( db-tables-rows)

How to connect from code:-
-------------------
install mongodb, mongoose 
create database.js file and connect to the mongoose using connection string (connecting to the devtinder database)
in app.js file connect to db and listen to server

EPISODE - 5
------------------

 
DIFFERENCE BETWEEN find and findOne
****************************8
find(): Retrieves multiple documents as a cursor, used when expecting more than one result.
findOne(): Retrieves a single document that matches the query, or null if no match is found.








